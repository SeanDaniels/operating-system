#+TITLE: P3 Report
* Brief description of implementation of deadlock detection and priority inversion avoidance
** Deadlock Detection
A deadlock occurs when there is a circular dependency between two locks and two processes. The clearest way to illustrate a deadlock is with the following example:
Let some process be process_x, some other process be process_y. Let some lock by lock_a, some other lock be lock_b. A deadlock will occur if process_x owns lock_a, process_x is waiting on lock_b, lock_b is owned by process_b, and process_b is waiting on lock_a. Essentially, the two processes have locked eachother out from aqcuiring the lock's they need to move forward. A deadlock can contain a chain of processes and locks, but the cause of the deadlock is always limited to the relationship between two processes waiting on two locks.

In order to identify a deadlock, some state information is necessary for all locks and all processes. The needed state information for processes is what lock, if any, they are waiting on. For locks, the state information that is needed is what process, if any, currently owns them. I added the process state field to the process entry structure and the lock state field to al_lock structure.

The presence of a deadlock is determined when a process is attempting to lock any lock. When the process has moved beyond the guard of the lock function, the lock that the process is attempting to acquire is passed to the 'get_owner' function. The get owner function is a recursive function that locates locks within the al_locktable structure and returns the PID of the locks owner. If the lock has an owner, the owner's process table entry is referenced to determine if the owner is waiting on a lock. If the owner is waiting on a lock, the 'get_owner' function is called again. This recursion continues until a lock in the dependency chain is located that doesn't have an owner, an owning process in the dependency chain isn't waiting on any lock, or an owning process is waiting on the root lock, which is the lock that was initially passed to the 'get_owner' function. If the recursion terminates because of the last scenario, a value is set that is checked if the process attempting to gain control of the lock is parked. If that value confirmed, the dependency chain is printed to the console.

a process is waiting on a lock that is owned by process that is waiting on a lock that is owned by the process that is waiting.In order to implement a system that automatically detected the presence of a deadlock.
* Brief description of test cases
