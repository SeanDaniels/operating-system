#+TITLE: P3 Report
* Brief description of implementation of deadlock detection and priority inversion avoidance
** Deadlock Detection
A deadlock occurs when there is a circular dependency between two locks and two processes. The clearest way to illustrate a deadlock is with the following example:
Let some process be process_x, some other process be process_y. Let some lock by lock_a, some other lock be lock_b. A deadlock will occur if process_x owns lock_a, process_x is waiting on lock_b, lock_b is owned by process_b, and process_b is waiting on lock_a. Essentially, the two processes have locked eachother out from aqcuiring the lock's they need to move forward. A deadlock can contain a chain of processes and locks, but the cause of the deadlock is always limited to the relationship between two processes waiting on two locks.

In order to identify a deadlock, some state information is necessary for all locks and all processes. The needed state information for processes is what lock, if any, they are waiting on. For locks, the state information that is needed is what process, if any, currently owns them. I added the process state field to the process entry structure and the lock state field to al_lock structure. An array of pointers stores all of the locks that are created, so the state information of the locks can be referenced during run time.

The presence of a deadlock is determined when a process is attempting to lock any lock. When the process has moved beyond the guard of the lock function, the lock that the process is attempting to acquire is passed to the 'get_owner' function. The get owner function is a recursive function that locates locks within the al_locktable structure and returns the PID of the locks owner. If the lock has an owner, the owner's process table entry is referenced to determine if the owner is waiting on a lock. If the owner is waiting on a lock, the 'get_owner' function is called again. This recursion continues until a lock in the dependency chain is located that doesn't have an owner, an owning process in the dependency chain isn't waiting on any lock, or an owning process is waiting on the root lock, which is the lock that was initially passed to the 'get_owner' function. If the recursion terminates because of the last scenario, a value is set that is checked if the process attempting to gain control of the lock is parked. If that value confirmed, the dependency chain is printed to the console.
** Priority Inversion Avoidance
There is a scenario that produces priority inversion, which is when a process implicitly loses it's priority because it is waiting on a lock with a lower priority. In a scenario where a process with priority_low owns a lock, and priority_high is waiting on that lock, the higher priority task must wait for the lower priority task, which renders the priority of the processes useless. In order to avoid this, if a process attempts to gain control of a lock and fails, the priority of the process that owns the lock is compared the priority of the process that attempted to gain control. If the priority of the process that owns the lock is lower than the process that is trying to gain control, the priority of the process that owns the lock is elevated while it has the lock. This accomplished by saving the current priority of the process, copying the priority of the higher priority task, and rescheduling the lower priority task. If this happens, a bool value is set in the lock, which indicates that the process owning this lock has had a priority shift.

When a process is unparked, the bool value indicating the presence of a priority shift is checked. If the bool evaluates true, the original process priority is copied to the process that is releasing the lock.
* Brief description of test cases
** Deadlock Detection
In order to test for deadlocks, I updated main to contain a two seperate processes that competed for two locks. The first process, process_a, locks lock_a, locks lock_b, unlocks lock_a, and then unlocks lock_b. The second process, process_b, attempts to complete the inverse lock aquisition/release routine. What happens is that process_a locks lock_a, and process_b locks lock_b. When process_a attempts to lock lock_b, it can't, because lock_b is held by process_b. Because process_a is stalled waiting on lock_b, it doesn't release lock_a. The same thing happens for process_b relative to lock_a. This is a cyclic dependency, and it verifies the printing of the deadlock depenedencies.
** Priority Inversion Avoidance
In order to test for prioity inversion avoidance, I created three processes. The first process is a low priority process that locks lock_a. The second process is a medium priority process that spawns 10 processes that run for one second each. The third process is a high priority process that attempts to lock lock_a. 
