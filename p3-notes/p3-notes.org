#+TITLE: P3 Notes
* Requirements
- include/lock.h contains all lock variants
- each lock variant has seperate .c file
- no reliance on semaphores or interrupts
- assume a fixed number of locks
- no need to implement lock delete function
- return syserr if max number of locks of a particular type is reached
- unlock system calls return syserr if process tries to release a lock that it doesnt own
* Tasks
- Provide assembly implementation of atomic test_and_set function
- Implement spinlock based on test_and_set
* Spinlock
- needs initialization
- needs lock function
- needs unlock function
- sl_lock_t can be defined how I wish
- spinlock implementation should be in system/spinlock.c
- include in lock.h constant NSPINLOCKS definingh the max number of spinlocks that can be used, set NSPINLOCKS = 20
** syscalls
- syscall sl_initlock(sl_lock_t *lock)
- syscall sl_lock(sl_lock_t *lock)
- syscall sl_unlock(sl_lock_t *lock)
* Stack Information
#+BEGIN_SRC C
int bar(int a, int b){
    int x, y;
    x = 555;
    y = a + b;
    return y;

}

void foo(void){
    bar(111, 222)
}
#+END_SRC
| Bottom of stack (in foo(void))         | Bottom of stack |                                                   |
| Saved EBP                              |                 |                                                   |
| 222                                    |                 |                                                   |
| 111                                    |                 | Now foo calls bar()                               |
| return address to foo                  |                 | On entry into bar, previous value of ebp is saved |
| saved ebp from foo                     | ebp             |                                                   |
| x                                      |                 |                                                   |
| y                                      |                 |                                                   |
| test_and_set(uint32 arg1, uint32 arg2) |                 |                                                   |
* Note on assembly function
  - Consider that, after ptr is read into EBX, EBX contains just a memory address. The xchg instruction needs to read the value at that memory location. So, you will need to use indirection to read and write memory: (EBX)
  - () -> indirection: get value at memory location %x
  - %ebp is a register, (%ebp) is the content of the register, x(%ebp) is an x offset from the content of the register
  - if your code uses EBX, you want to save the value of EBX on the stack after saving the value of EBP.
  - You don't need " movl 4(%ebp), %esp" at the end because the value of ESP is updated automatically.
  - At the end you need to pop EBX and EBP from the stack because you had pushed them on the stack at the beginning. But, you should not call popal, because it would pop all registers from the stack. But, you had not used pushal before, and so the content expected by popal is not on the stack.
* Test and set
#+BEGIN_SRC C
uint32 test_and_set(uint32 *ptr, uint32 new_value) {
    uint32 old_value = *ptr;
    *ptr = new_value;
    return old_value;
}
#+END_SRC
#+BEGIN_SRC asm
// working version, doesn't use xchg
test_and_set:
    pushl	%ebp
    movl	%esp, %ebp
    pushl %edx
    movl	8(%ebp), %eax // ptr to old_value
    movl	(%eax), %eax // return old_value, old_value = *ptr -> save content of old value to return register
    movl	%eax, -4(%ebp) // write %eax to return register???
    movl	8(%ebp), %eax // get ptr to old value again
    movl	12(%ebp), %edx // get new value
    movl	%edx, (%eax) // store new value at address indicated by old_value
    movl	-4(%ebp), %eax // load old_value into return value
    pop %edx
    pop %ebp
    ret
#+END_SRC
* Simple assembly addition function for reference
#+BEGIN_SRC asm
add_func:
    // eax used as return register
    pushl %ebp // store current ebp value onto stack
    //() -> indirection: get value at memory location %x
    movl %esp, %ebp // save current stack pointer into ebp register
    //%ebp is a register, (%ebp) is the content of the register, x(%ebp) is an x offset from the content of the register
    movl 8(%ebp), %edx // get arg 1 that was passed, store into ecx
    movl (%edx), %edx
    movl 12(%ebp), %eax // get arg 2 that was passed, store into eax

    addl %edx, %eax // add contents of eax and ebx, store into ebx
    popl %ebp
    ret
#+END_SRC
